# Objectives:
The intention of the dash config generator is to provide a way to build a large scale dash config. and to answer today the question `what is the "ip"?`

the dash config format is close to [dash-reference-config-example.md](../../../documentation/gnmi/design/dash-reference-config-example.md) with small changes.

this is not yet a config that can be deployed, but intends to be morphed into one as DASH standards get ratified and implemented

#  Usage:
to generate a dash config simply run `python generate.d.py` in the current directory

each section of the config file has it's own generator for example `enis` block is generated by `dashgen/enis.py` and `generate.d.py` brings all the blocks together and writes them into the json file

`variables.py` contains the parameters used by the generator
```
#for baby hero test:
IP_MAPPED_PER_ACL_RULE = 1
IP_PER_ACL_RULE = 1

#for hero test:
IP_MAPPED_PER_ACL_RULE = 40
IP_PER_ACL_RULE = 200
```

# Logic:
ACLs and Routes should not be summarized.

```
we start with the `ENI_COUNT`
for each eni we allocate a `MAC_L_START` and `IP_L_START`
  when moving to next ENI we increment the mac by `ENI_MAC_STEP` and the ip by `IP_STEP4`
  each eni has `ACL_TABLE_COUNT` inbound and `ACL_TABLE_COUNT` outbound NSGs
  
  ACLs:
    each NSG has `ACL_RULES_NSG` acl rules 
    each acl rule has `IP_PER_ACL_RULE` ip prefixes
    the acl rules priorities are alternating allow and deny
    odd/even ip's are allocated to allow/deny rules
    no ips from inbound are repeated in outbound rules or other way around  except a last rule in the last table of each direction that will allow the traffic to flow

  Static VxLAN map:
    not all ips will have a map entry only the first `IP_MAPPED_PER_ACL_RULE` ips from each acl rule will have a ip/mac map entry.
  
  Routing:
    all allow ips will have a route as well as some deny ips.
    route allocation is controlled by `IP_ROUTE_DIVIDER_PER_ACL_RULE`
    the ips of each acl will be divided in groups of `IP_ROUTE_DIVIDER_PER_ACL_RULE`
    there will be routes for all but one ip in each group in such a way to prevent route summarization.

    lets say `IP_ROUTE_DIVIDER_PER_ACL_RULE` is 8
    we will have a route for:
        1.128.0.0/30
        1.128.0.4/31
        1.128.0.7/32
        and then it repeats
        1.128.0.8/30......
    this way there is no route for 1.128.0.6
```

# Scale:


| 8 ENI Scenario  |  required |   generated config number |
| ----------------| --------- |---------------------------|
| ENI's/VPorts    | 8         | ENI_COUNT                            |
| NSGs            | 48        | ENI_COUNT * 2[^1] * ACL_TABLE_COUNT  |
| ACL rules       | 48000     | NSG * ACL_RULES_NSG                  |
| Prefixes        | 9.6M      | ACL * IP_PER_ACL_RULE                |
| Mapping Table   | 2M        | ACL * IP_MAPPED_PER_ACL_RULE         |
| Routes          | 1.6M      | ACL * (IP_PER_ACL_RULE / IP_ROUTE_DIVIDER_PER_ACL_RULE) *  log(IP_ROUTE_DIVIDER_PER_ACL_RULE, 2)  |

# Sample (low scale):
[sample_dash_conf.json](sample_dash_conf.json)


[^1]: we multiply by 2 because we have inbound and outbound

