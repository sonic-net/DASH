#include "utils.h"

static int deviceId = 0;

static std::unordered_multimap<sai_object_id_t, std::shared_ptr<p4::v1::TableEntry> > tableEntryMap;
static std::mutex tableLock;
static std::atomic<sai_object_id_t> nextId;

#define MUTEX std::lock_guard<std::mutex> _lock(tableLock);

std::unique_ptr<p4::v1::P4Runtime::Stub> stub;

void dash::utils::correctIpPrefix(void *ip, const void *mask, size_t length)
{
    DASH_LOG_ENTER();

    auto _ip = reinterpret_cast<uint8_t *>(ip);
    auto _mask = reinterpret_cast<const uint8_t *>(mask);

    for (size_t i = 0; i < length; i++)
    {
        _ip[i] = _ip[i] & _mask[i];
    }
}

int dash::utils::leadingNonZeroBits(const uint32_t ipv4)
{
    DASH_LOG_ENTER();

    auto firstSetBit = __builtin_ffs(ipv4);

    if (0==firstSetBit)
    {
        return 0;
    }

    return 33 - firstSetBit;
}

int dash::utils::leadingNonZeroBits(const sai_ip6_t& ipv6)
{
    DASH_LOG_ENTER();

    int trailingZeros = 0;

    for (int i = 0; i < 16; i+=4)
    {
        auto num = static_cast<uint32_t>(ipv6[i]) +
            (static_cast<uint32_t>(ipv6[i+1]) << 8) +
            (static_cast<uint32_t>(ipv6[i+2]) << 16) +
            (static_cast<uint32_t>(ipv6[i+3]) << 24);

        auto firstSetBit = leadingNonZeroBits(num);

        if (firstSetBit > 0)
        {
            return 129-trailingZeros-firstSetBit;
        }

        trailingZeros += 32;
    }

    return 0;
}

static int GetDeviceId()
{
    DASH_LOG_ENTER();

    return deviceId;
}

static std::string updateTypeStr(p4::v1::Update_Type updateType)
{
    DASH_LOG_ENTER();

    const google::protobuf::EnumDescriptor *descriptor = p4::v1::Update_Type_descriptor();

    return descriptor->FindValueByNumber(updateType)->name();
}

const sai_attribute_t* dash::utils::getMaskAttr(sai_attr_id_t id, uint32_t attr_count, const sai_attribute_t *attr_list)
{
    DASH_LOG_ENTER();

    for (uint32_t i = 0; i < attr_count; i++)
    {
        if (attr_list[i].id == id)
        {
            return &attr_list[i];
        }
    }

    return nullptr;
}

grpc::StatusCode dash::utils::MutateTableEntry(std::shared_ptr<p4::v1::TableEntry> entry, p4::v1::Update_Type updateType)
{
    DASH_LOG_ENTER();

    p4::v1::WriteRequest request;

    request.set_device_id(GetDeviceId());

    auto update = request.add_updates();

    update->set_type(updateType);

    auto entity = update->mutable_entity();

    entity->set_allocated_table_entry(entry.get());

    p4::v1::WriteResponse rep;

    grpc::ClientContext context;

    grpc::Status status = stub->Write(&context, request, &rep);

    if (status.ok())
    {
        DASH_LOG_NOTICE("GRPC call Write::%s OK %s", updateTypeStr(updateType).c_str(), entry->ShortDebugString().c_str());
    }
    else
    {
        DASH_LOG_ERROR("GRPC ERROR[%d]: %s, %s", status.error_code(), status.error_message().c_str(), status.error_details().c_str());
        DASH_LOG_ERROR("GRPC call Write::%s ERROR: %s", updateTypeStr(updateType).c_str(), entry->ShortDebugString().c_str());
    }

    //MILIND?? What is this? reference release? memory release?
    entity->release_table_entry();

    return status.error_code();
}

bool dash::utils::InsertInTable(std::shared_ptr<p4::v1::TableEntry> entry, sai_object_type_t objectType, sai_object_id_t *objId)
{
    DASH_LOG_ENTER();

    auto retCode = MutateTableEntry(entry, p4::v1::Update_Type_INSERT);

    if (grpc::StatusCode::OK != retCode)
    {
        return false;
    }

    MUTEX;

    if (*objId == 0)
    {
        *objId = NextObjectId(objectType);
    }

    tableEntryMap.insert(std::make_pair(*objId, entry));

    return true;
}

// TODO to be removed and merged
#define DASH_OBJECT_SHFT 48
#define DASH_MAKE_OID(_objtype, _objval) (sai_object_id_t)(((sai_object_id_t)_objtype<<DASH_OBJECT_SHFT)+(sai_object_id_t)_objval)

sai_object_id_t dash::utils::NextObjectId(sai_object_type_t objectType)
{
    DASH_LOG_ENTER();

    return DASH_MAKE_OID(objectType, ++nextId);
}

bool dash::utils::RemoveFromTable(sai_object_id_t id)
{
    DASH_LOG_ENTER();

    MUTEX;

    auto range = tableEntryMap.equal_range(id);

    if (range.first == range.second)
    {
        DASH_LOG_ERROR("id: %ld not present in the table for deletion!", id);

        return false;
    }

    grpc::StatusCode retCode = grpc::StatusCode::OK;

    for (auto itr = range.first; itr != range.second; ++itr)
    {
        auto entry = itr->second;
        auto tempRet = MutateTableEntry(entry, p4::v1::Update_Type_DELETE);

        if (grpc::StatusCode::OK != tempRet)
        {
            retCode = tempRet;
        }
    }

    tableEntryMap.erase(id);

    return retCode == grpc::StatusCode::OK;
}
