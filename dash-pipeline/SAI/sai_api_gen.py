#!/usr/bin/env python3

try:
    import os
    import json
    import argparse
    import copy
    from jinja2 import Template, Environment, FileSystemLoader
except ImportError as ie:
    print("Import failed for " + ie.name)
    exit(1)

NAME_TAG = 'name'
TABLES_TAG = 'tables'
BITWIDTH_TAG = 'bitwidth'
ACTIONS_TAG = 'actions'
ACTION_PARAMS_TAG = 'actionParams'
PREAMBLE_TAG = 'preamble'
OTHER_MATCH_TYPE_TAG = 'otherMatchType'
MATCH_TYPE_TAG = 'matchType'
PARAMS_TAG = 'params'
ACTION_REFS_TAG = 'actionRefs'
MATCH_FIELDS_TAG = 'matchFields'
NOACTION = 'NoAction'
STAGE_TAG = 'stage'
PARAM_ACTIONS = 'paramActions'
OBJECT_NAME_TAG = 'objectName'
SCOPE_TAG = 'scope'
TYPE_INFO_TAG = 'typeInfo'
SERIALIZABLE_ENUMS_TAG = 'serializableEnums'
MEMBERS_TAG = 'members'
STRUCTURED_ANNOTATIONS_TAG = 'structuredAnnotations'
KV_PAIRS_TAG = 'kvPairs'
KV_PAIR_LIST_TAG = 'kvPairList'
SAI_VAL_TAG = 'SaiVal'
SAI_TABLE_TAG = 'SaiTable'
SAI_API_ORDER_TAG = 'api_order'

BLANK_LINE_PLACEHOLDER = 'BLANK_LINE_PLACEHOLDER'

#
# SAI parser decorators:
#
def sai_parser_from_p4rt(cls):
    @staticmethod
    def create(p4rt_value, *args, **kwargs):
        sai_object = cls()
        sai_object.parse(p4rt_value, *args, **kwargs)
        return sai_object

    def parse(self, p4rt_value, *args, **kwargs):
        if 'name' in kwargs:
            self.name = kwargs['name']
            kwargs.pop('name')

        self.parse_basic_info_if_exists(p4rt_value)
        self.parse_p4rt(p4rt_value, *args, **kwargs)

        return

    setattr(cls, "from_p4rt", create)
    setattr(cls, "parse", parse)

    return cls

#
# Parsed SAI objects and parsers:
#
# The SAI objects are parsed from the P4Runtime JSON file, generated by p4 compiler, which contains the information
# of all tables and entry information.
# 
# The classes below are used to parse the P4Runtime JSON file to get the key information, so we can generate the SAI
# API headers and implementation files afterwards.
#
# At high level, the hiredarchy of the SAI objects is as follows:
#
# DASHSAIExtensions                     : All DASH SAI extensions.
# |- SAIEnum                            : A single enum type.
# |  |- SAIEnumMember                   : A single enum member within the enum.
# |- SAIAPISet                          : All information for a single SAI API set, such as routing or CA-PA mapping.
#    |- SAIAPITableData                 : All information for a single SAI API table used in the API set.
#       |- SAIAPITableKey               : Information of a single P4 table key defined in the table.
#       |- SAIAPITableAction  <-------| : Information of a single P4 table action defined used by the table.
#          |- SAIAPITableActionParam -| : Information of a single P4 table action parameter used by the action.
#
class SAITypeInfo:
    def __init__(self, name, field_func_prefix, default = None, is_enum = False):
        self.name = name
        self.field_func_prefix = field_func_prefix
        self.default = default
        self.is_enum = is_enum

class SAITypeSolver:
    sai_type_info_registry = {
        "bool": SAITypeInfo("bool", "booldata"),
        "sai_uint8_t": SAITypeInfo("sai_uint8_t", "u8"),
        "sai_object_id_t": SAITypeInfo("sai_object_id_t", "u16"),
        "sai_uint16_t": SAITypeInfo("sai_uint16_t", "u16"),
        "sai_ip_address_t": SAITypeInfo("sai_ip_address_t", "ipaddr"),
        "sai_ip_addr_family_t": SAITypeInfo("sai_ip_addr_family_t", "u32"),
        "sai_uint32_t": SAITypeInfo("sai_uint32_t", "u32"),
        "sai_uint64_t": SAITypeInfo("sai_uint64_t", "u64"),
        "sai_mac_t": SAITypeInfo("sai_mac_t", "mac"),
        "sai_ip_prefix_t": SAITypeInfo("sai_ip_prefix_t", "ipPrefix"),
        "sai_u8_list_t": SAITypeInfo("sai_u8_list_t", "u8list"),
        "sai_u16_list_t": SAITypeInfo("sai_u16_list_t", "u16list"),
        "sai_u32_list_t": SAITypeInfo("sai_u32_list_t", "u32list"),
        "sai_ip_prefix_list_t": SAITypeInfo("sai_ip_prefix_list_t", "ipprefixlist"),
        "sai_u32_range_t": SAITypeInfo("sai_u32_range_t", "u32range"),
        "sai_u8_range_list_t": SAITypeInfo("sai_u8_range_list_t", "u8rangelist"),
        "sai_u16_range_list_t": SAITypeInfo("sai_u16_range_list_t", "u16rangelist"),
        "sai_u32_range_list_t": SAITypeInfo("sai_u32_range_list_t", "u32rangelist"),
        "sai_u64_range_list_t": SAITypeInfo("sai_u64_range_list_t", "u64rangelist"),
        "sai_ipaddr_range_list_t": SAITypeInfo("sai_ipaddr_range_list_t", "ipaddrrangelist"),
    }

    @staticmethod
    def register_sai_type(name, field_func_prefix, default = None, is_enum = False):
        SAITypeSolver.sai_type_info_registry[name] = SAITypeInfo(name, field_func_prefix=field_func_prefix, default=default, is_enum=is_enum)

    @staticmethod
    def get_sai_type(sai_type):
        if sai_type not in SAITypeSolver.sai_type_info_registry:
            raise ValueError(f'sai_type={sai_type} is not supported')

        return SAITypeSolver.sai_type_info_registry[sai_type]

    @staticmethod
    def get_object_sai_type(object_size):
        sai_type_name = ""

        if object_size == 1:
            sai_type_name = 'bool'
        elif object_size <= 8:
            sai_type_name = 'sai_uint8_t'
        elif object_size <= 16:
            sai_type_name = 'sai_uint16_t'
        elif object_size <= 32:
            sai_type_name = 'sai_uint32_t'
        elif object_size == 48:
            sai_type_name = 'sai_mac_t'
        elif object_size <= 64:
            sai_type_name = 'sai_uint64_t'
        elif object_size == 128:
            sai_type_name = 'sai_ip_address_t'
        else:
            raise ValueError(f'key_size={object_size} is not supported')

        return SAITypeSolver.get_sai_type(sai_type_name)

    @staticmethod
    def get_match_key_sai_type(match_type, key_size):
        if match_type == 'exact' or match_type == 'optional' or match_type == 'ternary':
            return  SAITypeSolver.get_object_sai_type(key_size)
        elif match_type == 'lpm':
            return SAITypeSolver.__get_lpm_match_key_sai_type(key_size)
        elif match_type == 'list':
            return SAITypeSolver.__get_list_match_key_sai_type(key_size)
        elif match_type == 'range':
            return SAITypeSolver.__get_range_sai_type(key_size)
        elif match_type == 'range_list':
            return SAITypeSolver.__get_range_list_sai_type(key_size)
        else:
            raise ValueError(f"match_type={match_type} is not supported")

    @staticmethod
    def __get_lpm_match_key_sai_type(key_size):
        sai_type_name = ""

        # LPM match key should always be converted into IP prefix.
        if key_size == 32:
            sai_type_name = 'sai_ip_prefix_t'
        elif key_size == 128:
            sai_type_name = 'sai_ip_prefix_t'
        else:
            raise ValueError(f'key_size={key_size} is not supported')

        return SAITypeSolver.get_sai_type(sai_type_name)

    @staticmethod
    def __get_list_match_key_sai_type(key_size):
        sai_type_name = ""

        if key_size <= 8:
            sai_type_name = 'sai_u8_list_t'
        elif key_size <= 16:
            sai_type_name = 'sai_u16_list_t'
        elif key_size <= 32:
            sai_type_name = 'sai_u32_list_t'
        else:
            raise ValueError(f'key_size={key_size} is not supported')

        return SAITypeSolver.get_sai_type(sai_type_name)

    @staticmethod
    def __get_range_sai_type(key_size):
        sai_type_name = ""

        # In SAI, all ranges that having smaller size than 32-bits are passed as 32-bits, such as port ranges and etc.
        # So, we convert all ranges that is smaller than 32-bits to sai_u32_range_t by default.
        if key_size <= 32:
            sai_type_name = 'sai_u32_range_t'
        else:
            raise ValueError(f'key_size={key_size} is not supported')

        return SAITypeSolver.get_sai_type(sai_type_name)

    @staticmethod
    def __get_range_list_sai_type(key_size):
        sai_type_name = ""

        if key_size <= 8:
            sai_type_name = 'sai_u8_range_list_t'
        elif key_size <= 16:
            sai_type_name = 'sai_u16_range_list_t'
        elif key_size <= 32:
            sai_type_name = 'sai_u32_range_list_t'
        elif key_size <= 64:
            sai_type_name = 'sai_u64_range_list_t'
        else:
            raise ValueError(f'key_size={key_size} is not supported')

        return SAITypeSolver.get_sai_type(sai_type_name)


class SAIObject:
    def __init__(self):
        # Properties from P4Runtime preamble
        self.name = ''
        self.id = 0
        self.alias = ''

        # Properties from SAI annotations
        self.type = None
        self.isresourcetype = None
        self.isreadonly = None
        self.object_name = None
        self.skipattr = None
        self.field = None
        self.default = None

    def parse_basic_info_if_exists(self, p4rt_object):
        '''
        This method parses basic info, such as id and name, from either the object itself or the P4Runtime preamble object and populates the SAI object.

        Example P4Runtime preamble object:

            "preamble": {
                "id": 33810473,
                "name": "dash_ingress.outbound.acl.stage1:dash_acl_rule|dash_acl",
                "alias": "outbound.acl.stage1:dash_acl_rule|dash_acl"
            },
        '''
        if PREAMBLE_TAG in p4rt_object:
            preamble = p4rt_object[PREAMBLE_TAG]
            self.id = preamble['id']
            self.name = preamble['name']
            self.alias = preamble['alias']
        else:
            self.id = p4rt_object['id'] if 'id' in p4rt_object else self.id
            self.name = p4rt_object['name'] if 'name' in p4rt_object else self.name

        # We only care about the last piece of the name, which is the actual object name.
        if '.' in self.name:
            name_parts = self.name.split('.')
            self.name = name_parts[-1]
        
        return

    def _parse_sai_object_annotation(self, p4rt_anno_list):
        '''
        This method parses the SAI annotations and populates the SAI object.
        
        Example SAI annotations:

            {
                "name": "Sai",
                "kvPairList": {
                    "kvPairs": [
                        { "key": "type", "value": { "stringValue": "sai_ip_addr_family_t" } },
                        { "key": "isresourcetype", "value": { "stringValue": "true" } }
                    ]
                }
            }

        Whenever a new attribute is introduced, please update the doc here to get it captured: dash-pipeline/bmv2/README.md.
        '''
        for anno in p4rt_anno_list[STRUCTURED_ANNOTATIONS_TAG]:
            if anno[NAME_TAG] == SAI_VAL_TAG:
                for kv in anno[KV_PAIR_LIST_TAG][KV_PAIRS_TAG]:
                    if kv['key'] == 'name':
                        self.name = kv['value']['stringValue']
                    elif kv['key'] == 'type':
                        self.type = kv['value']['stringValue']
                    elif kv['key'] == 'default_value':  # "default" is a reserved keyword and cannot be used.
                        self.default = kv['value']['stringValue']
                    elif kv['key'] == 'isresourcetype':
                        self.isresourcetype = kv['value']['stringValue']
                    elif kv['key'] == 'isreadonly':
                        self.isreadonly = kv['value']['stringValue']
                    elif kv['key'] == 'objects':
                        self.object_name = kv['value']['stringValue']
                    elif kv['key'] == 'skipattr':
                        self.skipattr = kv['value']['stringValue']
                    else:
                        raise ValueError("Unknown attr annotation " + kv['key'])

    def _link_ip_is_v6_vars(self, vars):
        # Link *_is_v6 var to its corresponding var.
        ip_is_v6_key_ids = {v.name.replace("_is_v6", ""): v.id for v in vars if '_is_v6' in v.name}

        for v in vars:
            if v.name in ip_is_v6_key_ids:
                v.ip_is_v6_field_id = ip_is_v6_key_ids[v.name]

        # Delete all vars with *_is_v6 in their names.
        return [v for v in vars if '_is_v6' not in v.name]


@sai_parser_from_p4rt
class SAIEnumMember(SAIObject):
    '''
    This class represents a single SAI enum member and provides parser from the P4Runtime enum member object
    '''
    def __init__(self):
        super().__init__()
        self.p4rt_value = ""

    def parse_p4rt(self, p4rt_member):
        '''
        This method parses the P4Runtime enum member object and populates the SAI enum member object.

        Example P4Runtime enum member object:

            { "name": "INVALID", "value": "AAA=" }
        '''
        self.p4rt_value = p4rt_member["value"]


@sai_parser_from_p4rt
class SAIEnum(SAIObject):
    '''
    This class represents a single SAI enum and provides parser from the P4Runtime enum object
    '''
    def __init__(self):
        super().__init__()
        self.bitwidth = 0
        self.members = []
        
    def parse_p4rt(self, p4rt_enum):
        '''
        This method parses the P4Runtime enum object and populates the SAI enum object.
        
        Example P4Runtime enum object:

            "dash_encapsulation_t": {
                "underlyingType": { "bitwidth": 16 },
                "members": [
                    { "name": "INVALID", "value": "AAA=" },
                    { "name": "VXLAN", "value": "AAE=" },
                    { "name": "NVGRE", "value": "AAI=" }
                ]
            }
        '''
        print("Parsing enum: " + self.name)

        self.name = self.name[:-2]
        self.bitwidth = p4rt_enum['underlyingType'][BITWIDTH_TAG]
        self.members = [SAIEnumMember.from_p4rt(enum_member) for enum_member in p4rt_enum[MEMBERS_TAG]]

        # Register enum type info.
        SAITypeSolver.register_sai_type(
            'sai_' + self.name + '_t',
            "s32",
            default = 'SAI_' + self.name.upper() + "_" + self.members[0].name.upper(),
            is_enum = True)


@sai_parser_from_p4rt
class SAIAPITableKey(SAIObject):
    '''
    This class represents a single SAI API table key and provides parser from the P4Runtime table key object.
    '''
    def __init__(self):
        super().__init__()
        self.match_type = ""
        self.bitwidth = 0
        self.ip_is_v6_field_id = 0

    def parse_p4rt(self, p4rt_table_key):
        '''
        This method parses the P4Runtime table key object and populates the SAI API table key object.

        Example P4Runtime table key object:

            {
                "id": 1,
                "name": "meta.vnet_id:vnet_id",
                "bitwidth": 16,
                "matchType": "EXACT"
            },
            {
                "id": 2,
                "name": "hdr.ipv4.src_addr:sip",
                "bitwidth": 32,
                "matchType": "EXACT"
            }
        '''

        self.bitwidth = p4rt_table_key[BITWIDTH_TAG]
        # print("Parsing table key: " + self.name)

        if OTHER_MATCH_TYPE_TAG in p4rt_table_key:
            self.match_type =  p4rt_table_key[OTHER_MATCH_TYPE_TAG].lower()
        elif MATCH_TYPE_TAG in p4rt_table_key:
            self.match_type =  p4rt_table_key[MATCH_TYPE_TAG].lower()
        else:
            raise ValueError(f'No valid match tag found')

        if STRUCTURED_ANNOTATIONS_TAG in p4rt_table_key:
            self._parse_sai_object_annotation(p4rt_table_key)

        # If type is specified, use it. Otherwise, try to find the proper type using default heuristics.
        if self.type != None:
            sai_type_info = SAITypeSolver.get_sai_type(self.type)
        else:
            sai_type_info = SAITypeSolver.get_match_key_sai_type(self.match_type, self.bitwidth)
            self.type = sai_type_info.name

        self.field = sai_type_info.field_func_prefix
        if self.default == None and sai_type_info.is_enum:
            self.default = sai_type_info.default

        return


@sai_parser_from_p4rt
class SAIAPITableAction(SAIObject):
    def __init__(self):
        super().__init__()
        self.params = []

    def parse_p4rt(self, p4rt_table_action, sai_enums):
        '''
        This method parses the P4Runtime table action object and populates the SAI API table action object.

        Example P4Runtime table action object:

            {
                "preamble": {
                    "id": 25364446,
                    "name": "dash_ingress.outbound.route_vnet",
                    "alias": "route_vnet"
                },
                "params": [
                    { "id": 1, "name": "dst_vnet_id", "bitwidth": 16 },
                    { "id": 2, "name": "meter_policy_en", "bitwidth": 1 },
                    { "id": 3, "name": "meter_class", "bitwidth": 16 }
                ]
            }
        '''
        # print("Parsing table action: " + self.name)
        self.parse_action_params(p4rt_table_action, sai_enums)

    def parse_action_params(self, p4rt_table_action, sai_enums):
        if PARAMS_TAG not in p4rt_table_action:
            return

        # Parse all params.
        for p in p4rt_table_action[PARAMS_TAG]:
            param = SAIAPITableActionParam.from_p4rt(p)
            self.params.append(param)

        self.params = self._link_ip_is_v6_vars(self.params)

        return


@sai_parser_from_p4rt
class SAIAPITableActionParam(SAIObject):
    def __init__(self):
        super().__init__()
        self.bitwidth = 0
        self.ip_is_v6_field_id = 0
        self.param_actions = []

    def parse_p4rt(self, p4rt_table_action_param):
        '''
        This method parses the P4Runtime table action object and populates the SAI API table action object.

        Example P4Runtime table action object:

            { "id": 1, "name": "dst_vnet_id", "bitwidth": 16 }
        '''
        self.bitwidth = p4rt_table_action_param[BITWIDTH_TAG]
        # print("Parsing table action param: " + self.name)

        if STRUCTURED_ANNOTATIONS_TAG in p4rt_table_action_param:
            self._parse_sai_object_annotation(p4rt_table_action_param)

        # If type is specified, use it. Otherwise, try to find the proper type using default heuristics.
        if self.type != None:
            sai_type_info = SAITypeSolver.get_sai_type(self.type)
        else:
            sai_type_info = SAITypeSolver.get_object_sai_type(self.bitwidth)
            self.type = sai_type_info.name

        self.field = sai_type_info.field_func_prefix
        if self.default == None and sai_type_info.is_enum:
            self.default = sai_type_info.default

        return


@sai_parser_from_p4rt
class SAIAPITableData(SAIObject):
    '''
    This class represents a single SAI API set and provides parser from the P4Runtime table object
    '''
    def __init__(self):
        super().__init__()
        self.ignored = False
        self.api_name = ""
        self.ipaddr_family_attr = 'false'
        self.keys = []
        self.actions = []
        self.action_params = []
        self.with_counters = 'false'

        # Extra properties from annotations
        self.stage = None
        self.is_object = None
        self.api_order = 0
        self.api_type = None

    def parse_p4rt(self, p4rt_table, program, all_actions, ignore_tables):
        '''
        This method parses the P4Runtime table object and populates the SAI API table object.

        Example P4Runtime table object:

            {
                "preamble": {
                    "id": 49812549,
                    "name": "dash_ingress.outbound.acl.stage2:dash_acl_rule|dash_acl",
                    "alias": "outbound.acl.stage2:dash_acl_rule|dash_acl"
                },
                "matchFields": [
                    {
                        "id": 1,
                        "name": "meta.dash_acl_group_id:dash_acl_group_id",
                        "bitwidth": 16,
                        "matchType": "EXACT",
                        "structuredAnnotations": [...]
                    },
                    ...
                ],
                "actionRefs": [
                    { "id": 18858683 },
                    ...
                ],
                "directResourceIds": [ 334749261 ],
                "size": "1024"
            }
        '''
        self.__parse_sai_table_annotations(p4rt_table[PREAMBLE_TAG])

        # If tables are specified as ignored via CLI or annotations, skip them.
        if self.name in ignore_tables:
            self.ignored = True
        elif self.ignored:
            ignore_tables.append(self.name)

        if self.ignored:
            print("Ignoring table: " + self.name)
            return

        print("Parsing table: " + self.name)
        self.with_counters = self.__table_with_counters(program)
        self.__parse_table_keys(p4rt_table)
        self.__parse_table_actions(p4rt_table, all_actions)

        if self.is_object == None:
            if len(self.keys) == 1 and self.keys[0].name.endswith(self.name.split('.')[-1] + '_id'):
                self.is_object = 'true'
            elif len(self.keys) > 5:
                self.is_object = 'true'
            else:
                self.is_object = 'false'
                self.name = self.name + '_entry'

        return

    def __parse_sai_table_annotations(self, p4rt_table_preamble):
        if STRUCTURED_ANNOTATIONS_TAG not in p4rt_table_preamble:
            return

        for anno in p4rt_table_preamble[STRUCTURED_ANNOTATIONS_TAG]:
            if anno[NAME_TAG] == SAI_TABLE_TAG:
                for kv in anno[KV_PAIR_LIST_TAG][KV_PAIRS_TAG]:
                    if kv['key'] == 'isobject':
                        self.is_object = kv['value']['stringValue']
                    if kv['key'] == 'ignored':
                        self.ignored = True
                    if kv['key'] == 'name':
                        self.name = kv['value']['stringValue']
                    if kv['key'] == 'stage':
                        self.stage = kv['value']['stringValue']
                    if kv['key'] == 'api':
                        self.api_name = kv['value']['stringValue']
                    if kv['key'] == 'api_type':
                        self.api_type = kv['value']['stringValue']
                    if kv['key'] == 'api_order':
                        self.api_order = kv['value']['int64Value']

        return

    def __table_with_counters(self, program):
        for counter in program['directCounters']:
            if counter['directTableId'] == self.id:
                return 'true'
        return 'false'

    def __parse_table_keys(self, p4rt_table):
        for p4rt_table_key in p4rt_table[MATCH_FIELDS_TAG]:
            table_key = SAIAPITableKey.from_p4rt(p4rt_table_key)
            self.keys.append(table_key)

        self.keys = self._link_ip_is_v6_vars(self.keys)

        for p4rt_table_key in self.keys:
            if (p4rt_table_key.match_type == 'exact' and p4rt_table_key.type == 'sai_ip_address_t') or \
                (p4rt_table_key.match_type == 'ternary' and p4rt_table_key.type == 'sai_ip_address_t') or \
                (p4rt_table_key.match_type == 'lpm' and p4rt_table_key.type == 'sai_ip_prefix_t') or \
                (p4rt_table_key.match_type == 'list' and p4rt_table_key.type == 'sai_ip_prefix_list_t'):
                    self.ipaddr_family_attr = 'true'

        return

    def __parse_table_actions(self, p4rt_table, all_actions):
        for p4rt_table_action in p4rt_table[ACTION_REFS_TAG]:
            action_id = p4rt_table_action["id"]
            if all_actions[action_id].name != NOACTION and not (SCOPE_TAG in p4rt_table_action and p4rt_table_action[SCOPE_TAG] == 'DEFAULT_ONLY'):
                self.__merge_action_params_to_table_params(all_actions[action_id])
                self.actions.append(all_actions[action_id])

    def __merge_action_params_to_table_params(self, action):
        '''
        Merge all parameters of an action into a single list of parameters for the table.

        When merge the parameters, we need to handle duplications. If the same param passed to multiple actions,
        we only need to keep one copy of the param in the table, so we don't generate multiple SAI attributes.
        '''
        for action_param in action.params:
            # skip v4/v6 selector, as they are linked via parameter property.
            if '_is_v6' in action_param.name:
                continue

            for table_action_param in self.action_params:
                # Already have this param in the table.
                if table_action_param.name == action_param.name:
                    table_action_param.param_actions.append(action.name)
                    break
            else:
                # New param is found, add it to the table.
                action_param.param_actions = [action.name]
                self.action_params.append(action_param)


class DASHAPISet(SAIObject):
    '''
    This class holds all parsed SAI API info for a specific API set, such as routing or CA-PA mapping.
    '''
    def __init__(self, api_name):
        self.app_name = api_name
        self.api_type = None
        self.tables = []
    
    def add_table(self, table):
        if self.api_type == None:
            self.api_type = table.api_type
        elif self.api_type != table.api_type:
            raise ValueError(f'API type mismatch: CurrentType = {self.api_type}, NewTableAPIType = {table.api_type}')

        self.tables.append(table)


@sai_parser_from_p4rt
class DASHSAIExtensions(SAIObject):
    '''
    This class holds all parsed SAI APIs and provides parser for the generated p4 runtime json file
    '''
    def __init__(self):
        super().__init__()
        self.sai_enums = []
        self.sai_apis = []

    @staticmethod
    def from_p4rt_file(p4rt_json_file_path, ignore_tables):
        print("Parsing SAI APIs BMv2 P4Runtime Json file: " + p4rt_json_file_path)
        with open(p4rt_json_file_path) as p4rt_json_file:
            p4rt = json.load(p4rt_json_file)

        return DASHSAIExtensions.from_p4rt(p4rt, name = 'dash_sai_apis', ignore_tables = ignore_tables)

    def parse_p4rt(self, p4rt_value, ignore_tables):
        self.__parse_sai_enums_from_p4rt(p4rt_value)
        self.__parse_sai_apis_from_p4rt(p4rt_value, ignore_tables)
        self.__update_table_param_object_name_reference()

    def __parse_sai_enums_from_p4rt(self, p4rt_value):
        all_p4rt_enums = p4rt_value[TYPE_INFO_TAG][SERIALIZABLE_ENUMS_TAG]
        self.sai_enums = [SAIEnum.from_p4rt(enum_value, name = enum_name) for enum_name, enum_value in all_p4rt_enums.items()]

    def __parse_sai_apis_from_p4rt(self, program, ignore_tables):
        # Parse all actions.
        actions = self.__parse_sai_table_action(program[ACTIONS_TAG], self.sai_enums)

        # Parse all tables into SAI API sets.
        tables = sorted(program[TABLES_TAG], key=lambda k: k[PREAMBLE_TAG][NAME_TAG])
        for table in tables:
            sai_api_table_data = SAIAPITableData.from_p4rt(table, program, actions, ignore_tables)
            if sai_api_table_data.ignored:
                continue

            for sai_api in self.sai_apis:
                if sai_api.app_name == sai_api_table_data.api_name:
                    sai_api.add_table(sai_api_table_data)
                    break
            else:
                new_api = DASHAPISet(sai_api_table_data.api_name)
                new_api.add_table(sai_api_table_data)
                self.sai_apis.append(new_api)

        # Sort all parsed tables by API order, so we can always generate the APIs in the same order for keeping ABI compatibility.
        for sai_api in self.sai_apis:
            sai_api.tables.sort(key=lambda x: x.api_order)

    def __update_table_param_object_name_reference(self):
        all_table_names = [table.name for api in self.sai_apis for table in api.tables]
    
        for sai_api in self.sai_apis:
            # Update object name reference for action params
            for table in sai_api.tables:
                for param in table.action_params:
                    if param.type == 'sai_object_id_t':
                        table_ref = param.name[:-len("_id")]
                        for table_name in all_table_names:
                            if table_ref.endswith(table_name):
                                param.object_name = table_name

            # Update object name reference for keys
            for table in sai_api.tables:
                for key in table.keys:
                    if key.type != None:
                        if key.type == 'sai_object_id_t':
                            table_ref = key.name[:-len("_id")]
                            for table_name in all_table_names:
                                if table_ref.endswith(table_name):
                                    key.object_name = table_name


    def __parse_sai_table_action(self, p4rt_actions, sai_enums):
        action_data = {}
        for p4rt_action in p4rt_actions:
            action = SAIAPITableAction.from_p4rt(p4rt_action, sai_enums)
            action_data[action.id] = action
        return action_data

#
# SAI Generators:
#
class SAIFileUpdater:
    def __init__(self, file_path):
        self.file_path = file_path

    def __enter__(self):
        with open(self.file_path, 'r') as f:
            self.lines = f.readlines()
        return self
 
    def __exit__(self, *args):
        print("Updating file: " + self.file_path + " ...")
        SAIFileUpdater.write_if_different(self.file_path, ''.join(self.lines))

    def remove_existing_items(self, insert_lines, existing_lines):
        new_lines = []
        pre_is_blank_line = True

        for line in [insert_line for insert_line in insert_lines
                     if insert_line.strip() not in existing_lines]:
            if line == BLANK_LINE_PLACEHOLDER:
                if not pre_is_blank_line:
                    new_lines.append('\n')
                    pre_is_blank_line = True
            else:
                pre_is_blank_line = False
                new_lines.append(line + '\n')

        return new_lines

    def insert_before(self, target_line, insert_lines, new_line_only=False):
        new_lines = []

        existing_lines = set([l.strip() for l in self.lines])
        for line in self.lines:
            if target_line in line:
                if new_line_only:
                    new_lines.extend(self.remove_existing_items(insert_lines, existing_lines))

                else:
                    new_lines.extend(['\n' if insert_line == BLANK_LINE_PLACEHOLDER
                                      else insert_line + '\n' for insert_line in insert_lines])

            new_lines.append(line)

        self.lines = new_lines

    def insert_after(self, target_line, insert_lines, new_line_only = False):
        new_lines = []

        existing_lines = set([l.strip() for l in self.lines])
        for line in self.lines:
            new_lines.append(line)
            if target_line in line:
                if new_line_only == True:
                    new_lines.extend(self.remove_existing_items(insert_lines, existing_lines))
                else:
                    new_lines.extend(['\n' if insert_line == BLANK_LINE_PLACEHOLDER
                                      else insert_line + '\n' for insert_line in insert_lines])

        self.lines = new_lines

    # don't write content to file if file already exists
    # and the content is the same, this will not touch
    # the file and let make utilize this
    @staticmethod
    def write_if_different(file, content):
        if os.path.isfile(file) == True:
            o = open(file, "r")
            data = o.read()
            o.close()
            if data == content:
                return # nothing to change, file is up to date
        with open(file, 'w') as o:
            o.write(content)

class SAITemplateRender:
    jinja2_env = None

    @classmethod
    def new_tm(cls, template_file_path):
        if cls.jinja2_env == None:
            cls.env = Environment(loader=FileSystemLoader('.'), trim_blocks=True, lstrip_blocks=True)
            cls.env.add_extension('jinja2.ext.loopcontrols')
            cls.env.add_extension('jinja2.ext.do')
        
        return cls.env.get_template(template_file_path)

    def __init__(self, template_file_path):
        self.template_file_path = template_file_path
        self.tm = SAITemplateRender.new_tm(template_file_path)

    def render(self, **kwargs):
        return self.tm.render(**kwargs)

    def render_to_file(self, target_file_path, **kwargs):
        print("Updating file: " + target_file_path + " (template = " + self.template_file_path + ") ...")
        rendered_str = self.tm.render(**kwargs)
        SAIFileUpdater.write_if_different(target_file_path, rendered_str)

class SAIGenerator:
    def __init__(self, dash_sai_ext):
        self.dash_sai_ext = dash_sai_ext
        self.sai_api_names = []
        self.generated_sai_api_extension_names = []
        self.generated_sai_type_extension_names = []
        self.generated_sai_object_entry_extension_names = []
        self.generated_header_file_names = []
        self.generated_impl_file_names = []

    def generate(self):
        print("\nGenerating all SAI APIs ...")

        for sai_api in self.dash_sai_ext.sai_apis:
            self.generate_sai_api(sai_api)

        self.generate_dash_sai_global_definitions()
        self.generate_sai_enum()
        self.generate_sai_fixed_api_files()

    def generate_sai_api(self, sai_api):
        print("\nGenerating DASH SAI API definitions and implementation for API: " + sai_api.app_name + " ...")

        self.sai_api_names.append(sai_api.app_name)
    
        # For new DASH APIs, we need to generate SAI API headers.
        unique_sai_api = self.__get_uniq_sai_api(sai_api)
        if sai_api.api_type != 'underlay':
            self.generate_dash_sai_definitions_for_api(unique_sai_api)

        # Generate SAI API implementation for all APIs.
        self.generate_sai_impl_file_for_api(sai_api)

    def generate_dash_sai_definitions_for_api(self, sai_api):
        # SAI header file
        sai_header_file_name = 'saiexperimental' + sai_api.app_name.replace('_', '') + '.h'
        SAITemplateRender('templates/saiapi.h.j2').render_to_file('SAI/experimental/' + sai_header_file_name, sai_api = sai_api)
        self.generated_header_file_names.append(sai_header_file_name)

        # Gather SAI API extension name and object types
        self.generated_sai_api_extension_names.append('    SAI_API_' + sai_api.app_name.upper() + ',')
        self.generated_sai_api_extension_names.append(BLANK_LINE_PLACEHOLDER)

        for table in sai_api.tables:
            self.generated_sai_type_extension_names.append('    SAI_OBJECT_TYPE_' + table.name.upper() + ',')
            self.generated_sai_type_extension_names.append(BLANK_LINE_PLACEHOLDER)

            if table.is_object == 'false':
                self.generated_sai_object_entry_extension_names.append('    /** @validonly object_type == SAI_OBJECT_TYPE_' + table.name.upper() + ' */')
                self.generated_sai_object_entry_extension_names.append('    sai_' + table.name + '_t ' + table.name + ';')
                self.generated_sai_object_entry_extension_names.append(BLANK_LINE_PLACEHOLDER)

        return

    def generate_sai_impl_file_for_api(self, sai_api):
        sai_impl_file_name = 'sai' + sai_api.app_name.replace('_', '') + '.cpp'
        header_prefix = "experimental" if sai_api.api_type != "underlay" else ""
        SAITemplateRender('templates/saiapi.cpp.j2').render_to_file('lib/' + sai_impl_file_name, tables = sai_api.tables, app_name = sai_api.app_name, header_prefix = header_prefix)
        self.generated_impl_file_names.append(sai_impl_file_name)

    def generate_dash_sai_global_definitions(self):
        print("\nGenerating DASH SAI API global definitions ...")

        # Update SAI extensions with API names and includes
        with SAIFileUpdater('SAI/experimental/saiextensions.h') as f:
            f.insert_before('Add new experimental APIs above this line', self.generated_sai_api_extension_names, new_line_only=True)
            f.insert_after('new experimental object type includes', ['#include "{}"'.format(f) for f in self.generated_header_file_names], new_line_only=True)

        # Update SAI type extensions with object types
        with SAIFileUpdater('SAI/experimental/saitypesextensions.h') as f:
            f.insert_before('Add new experimental object types above this line', self.generated_sai_type_extension_names, new_line_only=True)

        # Update SAI object struct for entries
        with SAIFileUpdater('SAI/inc/saiobject.h') as f:
            f.insert_before('Add new experimental entries above this line', self.generated_sai_object_entry_extension_names, new_line_only=True)
            f.insert_after('new experimental object type includes', ["#include <{}>".format(f) for f in self.generated_header_file_names], new_line_only=True)

        return

    def generate_sai_enum(self):
        new_sai_enums = []
        with open('SAI/experimental/saitypesextensions.h', 'r') as f:
            content = f.read()
            for enum in self.dash_sai_ext.sai_enums:
                if enum.name not in content:
                    new_sai_enums.append(enum)

        sai_enums_str = SAITemplateRender('templates/saienums.j2').render(sai_enums = new_sai_enums)
        sai_enums_lines = [s.rstrip(" \n") for s in sai_enums_str.split('\n')]
        sai_enums_lines = sai_enums_lines[:-1] # Remove the last empty line, so we won't add extra empty line to the file.

        with SAIFileUpdater('SAI/experimental/saitypesextensions.h') as f:
            f.insert_before('/* __SAITYPESEXTENSIONS_H_ */', sai_enums_lines)

    def generate_sai_fixed_api_files(self):
        print("\nGenerating SAI fixed APIs ...")
        for filename in ['saifixedapis.cpp', 'saiimpl.h']:
            SAITemplateRender('templates/%s.j2' % filename).render_to_file('lib/%s' % filename, api_names = self.sai_api_names)

    def __get_uniq_sai_api(self, sai_api):
        """ Only keep one table per group(with same table name) """
        groups = set()
        sai_api = copy.deepcopy(sai_api)
        tables = []
        for table in sai_api.tables:
            if table.name in groups:
                continue
            tables.append(table)
            groups.add(table.name)
        sai_api.tables = tables
        return sai_api


if __name__ == "__main__":
    # CLI
    parser = argparse.ArgumentParser(description='P4 SAI API generator')
    parser.add_argument('filepath', type=str, help='Path to P4 program RUNTIME JSON file')
    parser.add_argument('apiname', type=str, help='Name of the new SAI API')
    parser.add_argument('--print-sai-lib', type=bool)
    parser.add_argument('--ignore-tables', type=str, default='', help='Comma separated list of tables to ignore')
    args = parser.parse_args()

    p4rt_file_path = os.path.realpath(args.filepath)
    if not os.path.isfile(p4rt_file_path):
        print('File ' + p4rt_file_path + ' does not exist')
        exit(1)

    os.chdir(os.path.dirname(os.path.realpath(__file__)))

    # Parse SAI data from P4 runtime json file
    dash_sai_exts = DASHSAIExtensions.from_p4rt_file(p4rt_file_path, args.ignore_tables.split(','))

    if args.print_sai_lib:
        print("Dumping parsed SAI data:")
        print(json.dumps(dash_sai_exts, indent=2))

    # Generate and update all SAI files
    SAIGenerator(dash_sai_exts).generate()
